server:
  port: 8086

base-url:
  context: /axonect/aee/templates/v1.0/base-template
app:
  host: /MICROSERVICE_NAME/

log:
  identifierKey: UUID
  isDebug: true
info:
  app:
    name :  base-template
    msName : base-template
com:
  adl:
    dte:
      plugins:
        logging:
          enabled: true
          level: DEBUG
        rolling:
          policy: size
          size: 100000kb
        alarming:
          enabled: true
        msstat:
          enabled: true

logging:
  level:
    com.axonect: DEBUG

springdoc:
  packagesToScan: com.axonect.aee.template.baseapp.application.controller
  pathsToMatch: /**
  swagger-ui:
    configUrl: /MICROSERVICE_NAME/v3/api-docs/swagger-config
    url: /MICROSERVICE_NAME/v3/api-docs
    disable-swagger-default-url: true
  api-docs:
    path: /v3/api-docs

spring:
  data:
    redis:
      # Redis Sentinel Configuration
      sentinel:
        master: mymaster  # Sentinel master name
        nodes:
          - redis-cluster-headless.csg-aaa-query-cache.svc.cluster.local:26379  # Sentinel node(s)
      password: S3cure_Redis_Pass_w0rd!  # Redis authentication password
      database: 0  # Redis database index
      timeout: 120000ms  # Command timeout (120 seconds)
      connect-timeout: 10000ms  # Connection timeout
      client-type: lettuce  # Use Lettuce instead of Jedis
      lettuce:
        pool:
          # Connection pool configuration for high performance with Sentinel
          max-active: 600     # Maximum active connections in pool (max-pool-size)
          max-idle: 300       # Maximum idle connections in pool
          min-idle: 50        # Minimum idle connections in pool (keep connections ready)
          max-wait: 3000ms    # Maximum time to wait for connection from pool (max-pool-waiting)
          time-between-eviction-runs: 20000ms  # Pool cleaner interval (pool-cleaner-interval)
        shutdown-timeout: 100ms  # Graceful shutdown timeout
        cluster:
          refresh:
            period: 60000ms  # Cluster topology refresh period
            adaptive: true   # Enable adaptive topology refresh
  cache:
    type: redis
    redis:
      time-to-live: 3600000  # Default TTL: 1 hour (in milliseconds)
      cache-null-values: false  # Don't cache null values
      use-key-prefix: true      # Use cache name as key prefix
      key-prefix: "scheduling-service:"
  datasource:
    url: jdbc:oracle:thin:@aaa-dev.cn8eyeqma3tp.ap-southeast-2.rds.amazonaws.com:1521/ORCL
#    url: jdbc:oracle:thin:@localhost:1522/ORCL
    username: aaa
    password: Aaa!89nky78D
    driver-class-name: oracle.jdbc.OracleDriver
    hikari:
      minimum-idle: 10  # Keep at least 10 connections ready
      maximum-pool-size: 50  # Increased from 20 to handle high volume
      idle-timeout: 300000      # 5 minutes: close idle connections faster
      connection-timeout: 20000 # 20 seconds to get a connection
      max-lifetime: 1800000     # 30 minutes: max life of a connection
      validation-timeout: 5000  # 5 seconds to validate connection (increased to avoid Oracle setNetworkTimeout issues)
      leak-detection-threshold: 60000  # 60 seconds: detect connection leaks
      initialization-fail-timeout: -1 # Allow unlimited time for initial pool setup (handles Oracle connection delays)
      pool-name: OraclePool
      auto-commit: false  # Explicit transaction control for better performance
      data-source-properties:
        oracle.jdbc.implicitStatementCacheSize: 50  # Cache prepared statements
        oracle.net.CONNECT_TIMEOUT: 20000  # 20 seconds
        oracle.jdbc.ReadTimeout: 60000  # 60 seconds for large queries
        v$session.program: scheduling-service  # Set program name for Oracle session tracking
  jpa:
    hibernate:
      ddl-auto: update
    show-sql: false  # Disable SQL logging in production for performance
    properties:
      hibernate:
        format_sql: false
        dialect: org.hibernate.dialect.OracleDialect
        jdbc:
          batch_size: 100  # Process 100 inserts/updates in a single batch
          fetch_size: 100  # Fetch 100 rows at a time from result set
          batch_versioned_data: true  # Enable batch updates for versioned entities
        order_inserts: true  # Order inserts by entity type for better batching
        order_updates: true  # Order updates by entity type for better batching
        connection:
          provider_disables_autocommit: false  # Let Hibernate manage transactions
        query:
          in_clause_parameter_padding: true  # Optimize IN clause queries
          plan_cache_max_size: 2048  # Increase query plan cache
          plan_parameter_metadata_max_size: 256
        max_fetch_depth: 3  # Limit depth of outer joins
        default_batch_fetch_size: 16  # Batch fetch associated entities
        cache:
          use_second_level_cache: false  # Disable L2 cache for batch jobs
          use_query_cache: false  # Disable query cache for batch jobs
        generate_statistics: false  # Disable for better performance

recurrent-service.chunk-size: 100
delete-expired-buckets.chunk-size: 100
delete-expired-buckets.schedule: "0 30 0 * * ?"  # Run daily at 12:30 AM

# Expiry Notification Configuration
expiry-notification:
  batch-size: 100                              # Number of bucket instances to process per batch
  schedule: "0 0 9 * * ?"                      # Run daily at 9:00 AM

# Kafka Configuration for Bucket Expiry Notifications
spring.kafka:
  bootstrap-servers: kafka-headless.cluster-one.svc.cluster.local:9092            # Kafka broker addresses (comma-separated for cluster)
  producer:
    retries: 3
    acks: all
    batch-size: 16384
    linger-ms: 10
    buffer-memory: 33554432
    key-serializer: org.apache.kafka.common.serialization.StringSerializer
    value-serializer: org.springframework.kafka.support.serializer.JsonSerializer

# Kafka Topic Names
kafka.topic:
  bucket-expiry-notification: bucket-expiry-notifications  # Topic for bucket expiry notifications

# Cache API Configuration
cache.api.connect-timeout: 5000         # Connection timeout in milliseconds
cache.api.read-timeout: 10              # Read timeout in seconds
cache.api.write-timeout: 10             # Write timeout in seconds
cache.api.response-timeout: 10          # Response timeout in seconds
cache.api.max-connections: 100          # Maximum connections in pool
cache.api.pending-acquire-timeout: 45   # Timeout for acquiring connection from pool (seconds)

########### Base Urls ###################
#ams.base-url: http://aeb53274042be477aba79f9076056316-ee9e05124271e8a5.elb.ap-southeast-2.amazonaws.com/airtel-aaa-accounting-management-service/api/v1/cache
ams.base-url: http://localhost:9905//api/v1/cache

###########  Cache API URLS ###################
cache.api.base-url: ${ams.base-url}/addBucket/{bucketUsername}

# Request Timeout
cache.api.timeout.request: 10         # Individual request timeout in seconds

# Retry Configuration
cache.api.retry.max-attempts: 3       # Maximum retry attempts
cache.api.retry.initial-backoff: 2    # Initial backoff in seconds
cache.api.retry.max-backoff: 10       # Maximum backoff in seconds

# Parallel Processing Configuration
cache.api.parallel.concurrency: 10    # Number of concurrent API requests